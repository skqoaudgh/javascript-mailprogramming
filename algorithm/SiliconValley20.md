## 문제
~~~
Silicon Valley 20번 문제 - 19.06.27
  
정수 배열 arr이 있습니다. arr안의 각 원소의 값은 다음 원소의 인덱스입니다. 이렇게 서로 이어지는 원소들의 배열이 있을때, arr[0]부터 시작하여 모든 원소를 들린 다음 다시 arr[0]로 도착할 수 있는지 찾으시오.
단, 시간복잡도는 O(n), 공간복잡도는 O(1).

예제)
Input: [1, 2, 4, 0, 3]
Output: True
// 1 -> 2 -> 4 -> 3 -> 0 -> 1

Input: [1, 4, 5, 0, 3, 2]
Output: False
// 1 -> 4 -> 3 -> 0 -> 1
// arr[2], arr[5]를 들리지 않았습니다.

Input: [1, 2, 2, 0]
Output: False
// 1 -> 2 -> 2 -> 2 -> …
// arr[0]로 돌아오지 못합니다.
~~~

## 코드
~~~
function isCircuit(input) {
    const length = input.length;
    let i=0, cur=0, cnt=0;
    while(cnt <= input.length) {
        cur = input[cur];
        cnt ++;
        if(cnt > 1 && cur == input[0]) {
            break;
        }
    }
    if(cur == input[0] && cnt == input.length+1) {
        return true;
    }
    return false;
}
~~~

## 입출력
~~~
[1, 2, 4, 0, 3] -> true
[1, 4, 5, 0, 3, 2] -> false
[1, 2, 2, 0] -> false
[1, 2, 0, 4, 5, 6] -> false
[0] -> true
~~~

## 설명
~~~
1. 변수 cur은 현재 방문한 인덱스를 나타내고, cnt는 인덱스에 방문한 횟수를 나타낸다.
2. 인덱스의 값을 따라 방문을 하면서 cnt를 증가시키는데, (배열의 길이+1)의 값을 최대로 가진다.
3. 이 떄, 반복문이 끝나기 전에 다시 처음으로 돌아온다면 바로 반복문을 종료시킨다.
4. 최종 방문 인덱스가 처음이고, 방문한 횟수가 (배열의 길이+1)라면 true를 반환하고 그렇지 않다면 false를 반환한다.
5. 방문한 횟수가 (배열의 길이+1) 보다 작다는 것은 방문하지 않는 인덱스가 있다는 뜻이다.
6. 방문한 횟수가 (배열의 길이+1)이지만 최종 방문 인덱스가 처음이 아니라면 처음으로 돌아올 수 없다는 뜻이다.
~~~